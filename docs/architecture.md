# Архитектура системы управления задачами и проектами

## 1. Общая архитектура

Система построена на основе **многоуровневой (layered) архитектуры** с четким разделением ответственности между слоями. Это обеспечивает:
- Слабую связанность компонентов
- Высокую тестируемость
- Простоту сопровождения и развития

### Схема архитектуры:

```
┌─────────────────────────────────────┐
│     Presentation Layer (CLI)        │  <- Интерфейс пользователя
└──────────────┬──────────────────────┘
               │
┌──────────────▼──────────────────────┐
│     Business Logic Layer            │  <- Сервисы, бизнес-правила
│  (ProjectService, TaskService)      │
└──────────────┬──────────────────────┘
               │
┌──────────────▼──────────────────────┐
│     Data Access Layer               │  <- Репозитории
│     (Repository Pattern)            │
└──────────────┬──────────────────────┘
               │
┌──────────────▼──────────────────────┐
│     Domain Layer                    │  <- Модели данных
│  (User, Project, Task)              │
└─────────────────────────────────────┘
```

## 2. Описание слоев

### 2.1 Domain Layer (Слой предметной области)

**Назначение**: Содержит модели данных, представляющие основные сущности системы.

**Компоненты**:
- `User` - пользователь системы
- `Project` - проект с задачами
- `Task` - задача с описанием и статусом
- `TaskStatus` - перечисление статусов задачи
- `Priority` - перечисление приоритетов

**Принципы**:
- Модели содержат только данные и простую бизнес-логику
- Не зависят от других слоев
- Следуют принципу Single Responsibility

### 2.2 Data Access Layer (Слой доступа к данным)

**Назначение**: Абстрагирует работу с хранилищем данных.

**Компоненты**:
- `IRepository` - интерфейс репозитория (абстрактный класс)
- `InMemoryRepository` - реализация хранилища в памяти

**Паттерны**:
- **Repository Pattern** - обеспечивает единый интерфейс для работы с данными
- **Dependency Inversion** - зависимость от абстракции, а не от реализации

**Методы репозитория**:
```python
add(entity) -> None
get_by_id(id) -> Entity
get_all() -> List[Entity]
update(entity) -> None
delete(id) -> None
```

### 2.3 Business Logic Layer (Слой бизнес-логики)

**Назначение**: Реализует бизнес-правила и координирует работу системы.

**Компоненты**:
- `ProjectService` - управление проектами
- `TaskService` - управление задачами
- `UserService` - управление пользователями

**Ответственность**:
- Валидация входных данных
- Применение бизнес-правил
- Координация работы с репозиториями
- Обработка исключительных ситуаций

**Примеры бизнес-правил**:
- Нельзя создать задачу без проекта
- Только владелец проекта может его удалить
- Задача не может быть назначена несуществующему пользователю

### 2.4 Presentation Layer (Слой представления)

**Назначение**: Обеспечивает взаимодействие с пользователем.

**Компоненты**:
- `TaskManagerCLI` - консольный интерфейс

**Функции**:
- Отображение меню и результатов
- Получение ввода от пользователя
- Вызов методов сервисов
- Форматирование вывода

## 3. Ключевые паттерны проектирования

### 3.1 Repository Pattern
Обеспечивает абстракцию над хранилищем данных, позволяя легко менять источник данных (память, БД, файл).

### 3.2 Service Layer Pattern
Инкапсулирует бизнес-логику в отдельные сервисы, делая систему более модульной.

### 3.3 Dependency Injection
Сервисы получают зависимости (репозитории) через конструктор, что упрощает тестирование.

### 3.4 Enum Pattern
Использование перечислений для статусов и приоритетов предотвращает ошибки.

## 4. Принципы SOLID

### Single Responsibility Principle
Каждый класс имеет одну ответственность:
- `User` - представление пользователя
- `ProjectService` - логика работы с проектами
- `InMemoryRepository` - хранение данных

### Open/Closed Principle
Можно расширять функциональность через наследование (например, новые типы репозиториев) без изменения существующего кода.

### Liskov Substitution Principle
Любая реализация `IRepository` может быть использована вместо другой без изменения логики.

### Interface Segregation Principle
Интерфейсы узкие и специфичные (каждый репозиторий работает с одним типом сущности).

### Dependency Inversion Principle
Высокоуровневые модули (сервисы) зависят от абстракций (интерфейсов репозиториев), а не от конкретных реализаций.

## 5. Потоки данных

### Создание новой задачи:
1. Пользователь вводит данные через CLI
2. CLI вызывает `TaskService.create_task()`
3. TaskService валидирует данные
4. TaskService проверяет существование проекта через `ProjectRepository`
5. TaskService создает объект `Task`
6. TaskService сохраняет задачу через `TaskRepository.add()`
7. CLI отображает результат пользователю

## 6. Преимущества выбранной архитектуры

✅ **Модульность** - легко добавлять новые функции
✅ **Тестируемость** - каждый слой можно тестировать отдельно
✅ **Гибкость** - легко заменить хранилище или интерфейс
✅ **Понятность** - четкое разделение ответственности
✅ **Масштабируемость** - можно добавлять новые сервисы и репозитории

## 7. Возможные улучшения

1. **Добавление слоя API** (REST/GraphQL) для веб-доступа
2. **Реализация паттерна Unit of Work** для транзакций
3. **Добавление кэширования** для повышения производительности
4. **Реализация Event Sourcing** для истории изменений
5. **Использование базы данных** вместо хранения в памяти
6. **Добавление аутентификации и авторизации**
